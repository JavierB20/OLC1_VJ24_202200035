package analisis;

//importaciones
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import Abstracto.Instruccion;
import Simbolos.Tipo;
import Simbolos.tipoDato;
import Excepciones.Errores;

//instrucciones
import Instrucciones.Print;
import Instrucciones.AsignacionVar;
import Instrucciones.Declaracion;
import Instrucciones.If;
import Instrucciones.Break;
import Instrucciones.Match;
import Instrucciones.Caso;
import Instrucciones.While;
import Instrucciones.For;
import Instrucciones.Incremento;
import Instrucciones.Decremento;
import Instrucciones.Continue;
import Instrucciones.DoWhile;



//expresiones
import Expresiones.Nativo;
import Expresiones.Aritmeticas;
import Expresiones.OperadoresAritmeticos;
import Expresiones.OperadoresRelacionales;
import Expresiones.Relacionales;
import Expresiones.Logicos;
import Expresiones.OperadoresLogicos;
import Expresiones.Casteos;
import Expresiones.AccesoVar;




// parser
parser code
{:
    scanner s;
    parser(scanner s){this.s = s;}

    public LinkedList<Errores> listaErrores = new LinkedList<>();

    public void syntax_error(Symbol s){
        listaErrores.add(new Errores("SINTACTICO RECUPERABLE",
                        "No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }

    public void unrecovered_syntax_error (Symbol s){
        listaErrores.add(new Errores("SINTACTICO NO RECUPERABLE",
                        "No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }
:}


action code
{:
:}

//terminales
terminal String CADENA, ENTERO, DECIMAL, CARACTER, ID;
terminal IGUAL, FINCADENA, PRINTLN, DOSPUNTOS, LLAVE1, LLAVE2;
terminal PAR1, PAR2, MAS, MENOS, POTENCIA, MULT, DIV, MOD, UMENOS, GUIONBAJO;
terminal VERDAD, FALSO;
terminal IGUALACION, DIFERENCIA, MENORIGUAL, MENOR, MAYORIGUAL, MAYOR;
terminal TKNOT, TKOR, TKAND, TKXOR;
terminal TKDOUBLE, TKINT, TKCHAR, TKSTRING, TKBOOL;
terminal CONST, VAR;
terminal IF, ELSE, MATCH, WHILE, FOR, DO;
terminal String BREAK, CONTINUE;


//no terminales
nonterminal LinkedList<Instruccion> INICIO, INSTRUCCIONES, CASOS;
nonterminal Instruccion INSTRUCCION;
nonterminal Instruccion INSPRINTLN, DECLARACION, ASIGNACION, CASO;
nonterminal Tipo TIPOS;
nonterminal Instruccion EXPRESION;
nonterminal String MUTABILIDAD;
nonterminal Instruccion SIF, SMATCH, SWHILE, SFOR, ACTUALIZA_FOR, INCREMENTO, DECREMENTO;
nonterminal Instruccion SBREAK, SDEFAULT, SCONTINUE, SDOWHILE;


precedence left UMENOS;
precedence nonassoc POTENCIA;
precedence left MULT, DIV;
precedence left MAS, MENOS;
precedence left MOD;
precedence left IGUALACION, DIFERENCIA, MENOR, MENORIGUAL, MAYOR, MAYORIGUAL;
precedence left TKNOT;
precedence right TKXOR, TKAND, TKOR;

start with INICIO;

INICIO ::= INSTRUCCIONES:a      {:   RESULT = a;   :}
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b     {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a                     {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

INSTRUCCION ::= INSPRINTLN:a          {:   RESULT=a;   :}
                | DECLARACION:a       {:   RESULT=a;   :}
                | SIF:a               {:   RESULT=a;   :}
                | SMATCH:a            {:   RESULT=a;   :}
                | SWHILE:a            {:   RESULT=a;   :}
                | SDOWHILE:a          {:   RESULT=a;   :}
                | SFOR:a              {:   RESULT=a;   :}
                | INCREMENTO:a        {:   RESULT=a;   :}
                | DECREMENTO:a        {:   RESULT=a;   :}
                | SBREAK:a            {:   RESULT=a;   :}
                | SCONTINUE:a         {:   RESULT=a;   :}
                | ASIGNACION:a        {:   RESULT=a;   :}
                | error FINCADENA
                | error
;

INSPRINTLN ::= PRINTLN PAR1 EXPRESION:a PAR2 FINCADENA      {:   RESULT = new Print(a, aleft, aright);   :}
;

SBREAK ::= BREAK:a FINCADENA      {:    RESULT = new Break(aleft, aright);     :}
;

SCONTINUE ::= CONTINUE:a FINCADENA      {:    RESULT = new Continue(aleft, aright);     :}
;

//INICIO SENTENCIAS DE CONTROL
SIF ::=   IF PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2 ELSE SIF:c                           {:   RESULT = new If(a, b, c, aleft, aright);   :}
        | IF PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2 ELSE LLAVE1 INSTRUCCIONES:c LLAVE2   {:   RESULT = new If(a, b, c, aleft, aright);   :}
        | IF PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2                                      {:   RESULT = new If(a, b, aleft, aright);   :}
;

SMATCH ::= MATCH EXPRESION:a LLAVE1 CASOS:b LLAVE2              {: RESULT = new Match(a, b, null, aleft, aright); :}
        |  MATCH EXPRESION:a LLAVE1 SDEFAULT:c LLAVE2           {: RESULT = new Match(a, null, c, aleft, aright); :}
        |  MATCH EXPRESION:a LLAVE1 CASOS:b SDEFAULT:c LLAVE2   {: RESULT = new Match(a, b, c, aleft, aright); :}
;

CASOS ::= CASOS:a CASO:b            {: RESULT = a; RESULT.add(b); :}
        | CASO:a                   {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

CASO ::= EXPRESION:a IGUAL MAYOR LLAVE1 INSTRUCCIONES:b LLAVE2 {: RESULT = new Caso(a, b, aleft, aright); :}
;
        
SDEFAULT ::= GUIONBAJO IGUAL MAYOR LLAVE1 INSTRUCCIONES:a LLAVE2 {: RESULT = new Caso(a, aleft, aright); :}
;

//FIN SENTENCIAS DE CONTROL


//INICIO SENTENCIAS CICLICAS
SWHILE ::= WHILE PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2 {:  RESULT = new While(a, b, aleft, aright);   :} 
;

SDOWHILE ::= DO LLAVE1 INSTRUCCIONES:b LLAVE2 WHILE PAR1 EXPRESION:a PAR2 FINCADENA {:  RESULT = new DoWhile(a, b, aleft, aright);   :} 
;

SFOR ::= FOR PAR1 ASIGNACION:a EXPRESION:b FINCADENA ACTUALIZA_FOR:c PAR2 LLAVE1 INSTRUCCIONES:d LLAVE2     
{:   RESULT = new For(a, b, c, d, aleft, aright);   :}
;

//Colocar incremento y decremento
ACTUALIZA_FOR ::= INCREMENTO:a           {:   RESULT=a;  :}
                | DECREMENTO:a           {:   RESULT=a;  :}
                | ID:a IGUAL EXPRESION:b {:   RESULT=new AsignacionVar(a, b, aleft, aright);  :}
;

INCREMENTO ::=    ID:a MAS MAS FINCADENA {: RESULT=new Incremento(a, aleft, aright);  :}
                | ID:a MAS MAS           {: RESULT=new Incremento(a, aleft, aright);  :}
;

DECREMENTO ::=    ID:a MENOS MENOS FINCADENA {: RESULT=new Decremento(a, aleft, aright);  :}
                | ID:a MENOS MENOS           {: RESULT=new Decremento(a, aleft, aright);  :}
;
//FIN    SENTENCIAS CICLICAS

DECLARACION ::=   MUTABILIDAD:d ID:b DOSPUNTOS TIPOS:a FINCADENA                      {:   RESULT = new Declaracion(b, d, a, aleft, aright);   :}
                | MUTABILIDAD:d ID:b DOSPUNTOS TIPOS:a IGUAL EXPRESION:c FINCADENA    {:   RESULT = new Declaracion(b, c, d, a, aleft, aright);   :}
;

ASIGNACION ::= ID:a IGUAL EXPRESION:b FINCADENA  {:   RESULT=new AsignacionVar(a, b, aleft, aright);  :}
;


EXPRESION ::= MENOS EXPRESION:a                 {:   RESULT = new Aritmeticas(a, OperadoresAritmeticos.NEGACION, aleft, aright);   :} %prec UMENOS
            | TKNOT EXPRESION:a                 {:   RESULT = new Logicos(a, OperadoresLogicos.OPNOT, aleft, aright);   :}

            | EXPRESION:a MAS EXPRESION:b       {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.SUMA, aleft, aright);   :}
            | EXPRESION:a MENOS EXPRESION:b     {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.RESTA, aleft, aright);   :}
            | EXPRESION:a POTENCIA EXPRESION:b  {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.POTENCIA, aleft, aright);   :}
            | EXPRESION:a MULT EXPRESION:b      {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MULTIPLICACION, aleft, aright);   :}
            | EXPRESION:a DIV EXPRESION:b       {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.DIVISION, aleft, aright);   :}
            | EXPRESION:a MOD EXPRESION:b       {:   RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MODULO, aleft, aright);   :}

            | EXPRESION:a IGUALACION EXPRESION:b       {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.IGUALACION, aleft, aright);   :}
            | EXPRESION:a DIFERENCIA EXPRESION:b       {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.DIFERENCIA, aleft, aright);   :}
            | EXPRESION:a MENORIGUAL EXPRESION:b       {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.MENOROIGUAL, aleft, aright);   :}
            | EXPRESION:a MENOR EXPRESION:b            {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.MENORQUE, aleft, aright);   :}
            | EXPRESION:a MAYORIGUAL EXPRESION:b       {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.MAYOROIGUAL, aleft, aright);   :}
            | EXPRESION:a MAYOR EXPRESION:b            {:   RESULT = new Relacionales(a, b, OperadoresRelacionales.MAYORQUE, aleft, aright);   :}

            | EXPRESION:a TKAND EXPRESION:b            {:   RESULT = new Logicos(a, b, OperadoresLogicos.OPAND, aleft, aright);   :}
            | EXPRESION:a TKXOR EXPRESION:b            {:   RESULT = new Logicos(a, b, OperadoresLogicos.OPXOR, aleft, aright);   :}
            | EXPRESION:a TKOR EXPRESION:b             {:   RESULT = new Logicos(a, b, OperadoresLogicos.OPOR, aleft, aright);   :}

            | PAR1 TIPOS:a PAR2 EXPRESION:b             {:   RESULT = new Casteos(a, b, aleft, aright);   :}
        
            | PAR1 EXPRESION:a PAR2             {:   RESULT = a;   :}
            | ENTERO:a      {:   RESULT = new Nativo(Integer.parseInt(a), new Tipo(tipoDato.ENTERO), aleft, aright );   :}
            | DECIMAL:a     {:   RESULT = new Nativo(Double.parseDouble(a), new Tipo(tipoDato.DECIMAL), aleft, aright );   :}
            | CADENA:a      {:   RESULT = new Nativo(a, new Tipo(tipoDato.CADENA), aleft, aright );   :}
            | CARACTER:a    {:   RESULT = new Nativo(a, new Tipo(tipoDato.CARACTER), aleft, aright );   :}
            | VERDAD:a      {:   RESULT = new Nativo(a, new Tipo(tipoDato.BOOLEANO), aleft, aright );   :}
            | FALSO:a       {:   RESULT = new Nativo(a, new Tipo(tipoDato.BOOLEANO), aleft, aright );   :}
            | ID:a          {:   RESULT = new AccesoVar(a, aleft, aright);   :}

;

TIPOS ::= TKINT:a      {:   RESULT=new Tipo(tipoDato.ENTERO);   :}
        | TKDOUBLE:a   {:   RESULT=new Tipo(tipoDato.DECIMAL);   :}
        | TKCHAR:a     {:   RESULT=new Tipo(tipoDato.CARACTER);   :}
        | TKSTRING:a   {:   RESULT=new Tipo(tipoDato.CADENA);   :}
        | TKBOOL:a     {:   RESULT=new Tipo(tipoDato.BOOLEANO);   :}
;

MUTABILIDAD ::=   VAR:a   {:   RESULT=(String)a;   :}
                | CONST:a {:   RESULT=(String)a;   :}
;